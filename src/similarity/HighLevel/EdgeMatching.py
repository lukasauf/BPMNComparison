# Importing libraries for similarity score
from src.similarity.LowLevel.computation import compute_similarity
from src.util.helpers import *

"""
This module provides functions to compare a BPMN Standard Model (SM) and a BPMN Generated Model (GM) using the
edge matching algorithm. 

Functions:
    - get_gm_sources(gm): Retrieves source node values from the GM.
    - get_gm_targets(gm, aimed_indices): Retrieves target node values from the GM for specified indices.
    - get_aimed_indices(similarity_scores, threshold): Identifies indices of highest similarity scores.
    - types_equivalent(sm_edge, gm_edge): Checks equivalency of node types between SM and GM edges.
    - compare_models_em(sm, gm, weights, threshold): Compares SM and GM using the Edge Matching algorithm.
"""


def get_gm_sources(gm):
    """
    Get the values of the left side of the GM --> for all the source nodes of the model

    Args:
        gm (BPMN): The generated BPMN model (generated by the AI)

    Returns:
        list: the source nodes' values listed
    """
    sources = []
    for edge in gm.edges:
        check_index_access(edge, 0)
        sources.append(get_value(edge[0], gm))
    return sources    
         
def get_gm_targets(gm, aimed_indices):
    """
    Get the values of the right side of the GM --> for all the targets nodes of the model

    Args:
        gm (BPMN): The generated BPMN model (generated by the AI)
        aimed_indices (list): List of all indices of matches on the source side for edges in the GM

    Returns:
        list: the target nodes' values listed
    """
    targets = []
    for i in aimed_indices:
        check_index_access(gm.edges, i)
        check_index_access(gm.edges[i], 1)
        #list_edges[i][1] takes the key of the right side of a tuple, where the left side was similar
        targets.append(get_value(gm.edges[i][1], gm))
    return targets

def get_aimed_indices(similarity_scores, threshold):
    """
    Get the indices of the gm_list_edges with the highest similarity score 

    Args:
        similarity_scores (list): Similarity scores of one element of the SM with all elements of the GM
        threshold (int): Threshold for accepting the similarity value: Let elem1 and elem2 be text labels,  if sim(elem1, elem2) > threshold --> elem1 and elem2 are considered equal

    Returns:
        list: List containing the indices of similarity_scores (therefore gm_list_edges) with the highest similarity 
    """
    
    max = 0 
    aimed_indices = []
    
    for i, similarity_score in enumerate(similarity_scores):
        
        if similarity_score > threshold and similarity_score >= max:
            if similarity_score == max:
                aimed_indices.append(i)
            else:
                aimed_indices = [i]
            max = similarity_score        
    return aimed_indices

def types_equivalent(sm_edge, gm_edge):
    """
    Check whether the types of source/target nodes of SM and GM are equivalent, so they can be matched

    Args:
        sm_edge (list): Edge of the SM, where the first element in the list is the source side and the second element is the targets side
        gm_edge (list): Edge of the GM, where the first element in the list is the source side and the second element is the targets side
        
    Returns:
        bool: Boolean indicating whether the types are equivalent
    """
    check_index_access(gm_edge, 0)
    check_index_access(gm_edge, 1)
    check_index_access(sm_edge, 0)
    check_index_access(sm_edge, 1)
    return get_type(sm_edge[0]) == get_type(gm_edge[0]) and get_type(sm_edge[1]) == get_type(gm_edge[1])
             
def compare_models_em(sm, gm, weights, threshold):
    """
    Compare the two models Standard Model (SM) and Generated Model (GM) with the EdgeMatching algorithm.
    

    Args:
        sm (BPMN): The standard BPMN model (created by a human process modeler)
        gm (BPMN): The generated BPMN model (generated by the AI)
        weights (dict): Weights for the low level similarity to be applied (glove/BERT/syntactic)
        threshold (float): Threshold for accepting the similarity value: Let elem1 and elem2 be text labels,  if sim(elem1, elem2) > threshold --> elem1 and elem2 are considered equal 
    """
    #format gm_list_edges correctly to compare with sm_list_edges
    gm_sources = get_gm_sources(gm)
    opt_eq_map = []
    
    for i, sm_edge in enumerate(sm.edges):
        aimed_indices_source = []
        aimed_indices_target = []
        
        #first compare the source side of SM and GM list_edges
        check_index_access(sm_edge, 0)
        sm_source = get_value(sm_edge[0], sm)
        similarity_scores = compute_similarity(sm_source, gm_sources, weights)
        #the indices of the gm_list_edges where there is a match are stored in aimed_indices_source
        aimed_indices_source = get_aimed_indices(similarity_scores, threshold)
        
        #no match on source node of sm at sm_edge[i] and gm
        if len(aimed_indices_source) == 0:
            continue
           
        # if there is at least one match for the source node check for these edges the target node
        check_index_access(sm_edge, 1)
        sm_target = get_value(sm_edge[1], sm)
        gm_targets = get_gm_targets(gm, aimed_indices_source)
        similarity_scores = compute_similarity(sm_target, gm_targets, weights)
        aimed_indices_target = get_aimed_indices(similarity_scores, threshold)
    
        #find true positives
        for i_right in aimed_indices_target:
            check_index_access(aimed_indices_source, i_right)
            check_index_access(gm.edges, aimed_indices_source[i_right])
            gm_edge = gm.edges[aimed_indices_source[i_right]]
            
            #the edge of the sm/gm has no match yet (if it already has one, skip) AND the types of the matches must be equivalent (e.g. excl.gateway and parallelgateway are not the same! this is the case for 1_2.mmd Index 6 of SM with BERT similarity)
            if all(sm_edge != pair[0] for pair in opt_eq_map) and all(gm_edge != pair[1] for pair in opt_eq_map) and types_equivalent(sm_edge, gm_edge):
                opt_eq_map.append((sm_edge, gm_edge))
        
    return opt_eq_map


        
    