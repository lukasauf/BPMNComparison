# Importing libraries for similarity score
from src.similarity.LowLevel.computation import compute_similarity
from src.util.helpers import *


def get_gm_sources(gm):
    """
    Get the values of the left side of the GM --> for all the source nodes of the model

    Args:
        gm (BPMN): The generated BPMN model (generated by the AI)

    Returns:
        list: the source nodes' values listed
    """
    sources = []
    for edge in gm.edges:
        check_index_access(edge, 0)
        sources.append(get_value(edge[0], gm))
    return sources    
         
def get_gm_targets(gm, aimed_indices):
    """
    Get the values of the right side of the GM --> for all the targets nodes of the model

    Args:
        gm (BPMN): The generated BPMN model (generated by the AI)
        aimed_indices (list): List of all indices of matches on the source side for edges in the GM

    Returns:
        list: the target nodes' values listed
    """
    targets = []
    for i in aimed_indices:
        check_index_access(gm.edges, i)
        check_index_access(gm.edges[i], 1)
        #list_edges[i][1] takes the key of the right side of a tuple, where the left side was similar
        targets.append(get_value(gm.edges[i][1], gm))
    return targets

def get_aimed_indices(similarity_scores, threshold):
    """
    Get the indices of the gm_list_edges with the highest similarity score 

    Args:
        similarity_scores (list): Similarity scores of one element of the SM with all elements of the GM
        threshold (int): Threshold for accepting the similarity value: Let elem1 and elem2 be text labels,  if sim(elem1, elem2) > threshold --> elem1 and elem2 are considered equal

    Returns:
        list: List containing the indices of similarity_scores (therefore gm_list_edges) with the highest similarity 
    """
    
    max = 0 
    aimed_indices = []
    
    for i, similarity_score in enumerate(similarity_scores):
        
        #TODO: check for threshold and search for max --> List is used, as there could be more than 1 max
        # i.e. two exclusivegateways (x) on left side / two or more same tasks on left side
        if similarity_score > threshold and similarity_score >= max:
            if similarity_score == max:
                aimed_indices.append(i)
            else:
                aimed_indices = [i]
            max = similarity_score        
    return aimed_indices

def types_equivalent(sm_edge, gm_edge):
    """
    Check whether the types of source/target nodes of SM and GM are equivalent, so they can be matched

    Args:
        sm_edge (list): Edge of the SM, where the first element in the list is the source side and the second element is the targets side
        gm_edge (list): Edge of the GM, where the first element in the list is the source side and the second element is the targets side
        
    Returns:
        bool: Boolean indicating whether the types are equivalent
    """
    
    check_index_access(gm_edge, 0)
    check_index_access(gm_edge, 1)
    check_index_access(sm_edge, 0)
    check_index_access(sm_edge, 1)
    return get_type(sm_edge[0]) == get_type(gm_edge[0]) and get_type(sm_edge[1]) == get_type(gm_edge[1])
             
def compare_models_em(sm, gm, weights, threshold):
    """
    Compare the two models Standard Model (SM) and Generated Model (GM) with the EdgeMatching algorithm.
    

    Args:
        sm (BPMN): The standard BPMN model (created by a human process modeler)
        gm (BPMN): The generated BPMN model (generated by the AI)
        weights (dict): Weights for the low level similarity to be applied (glove/BERT/syntactic)
        threshold (float): Threshold for accepting the similarity value: Let elem1 and elem2 be text labels,  if sim(elem1, elem2) > threshold --> elem1 and elem2 are considered equal 
    """
    #format gm_list_edges correctly to compare with sm_list_edges
    gm_sources = get_gm_sources(gm)
    #print('GENERATED MODEL FORMATTED sources ARE:')
    #print(f'Gm Sources is {gm_sources} and type is {type(gm_sources)}')
    opt_eq_map = []
    #iterate over entire sm_list_edges 
    for i, sm_edge in enumerate(sm.edges):
        #print('****************************')
        #print(f'INDEX: {i} BEGINNING')
        #print('****************************')
        
        #print('LEFT/source SIDE')
        
        aimed_indices_source = []
        aimed_indices_target = []
        #first compare the left side of SM and GM list_edges
        check_index_access(sm_edge, 0)
        sm_source = get_value(sm_edge[0], sm)
        
        #similarity function (cosine, syntactic, ...) can be replaced here
        similarity_scores = compute_similarity(sm_source, gm_sources, weights)
        #the indices of the gm_list_edges where there is a match are stored in aimed_indices_source
        aimed_indices_source = get_aimed_indices(similarity_scores, threshold)
        
        #no match on left side of sm at sm_edge[i] and gm
        if len(aimed_indices_source) == 0:
            continue
           
        #print('****************************')
        #print(f'Aimed index is {aimed_indices_source}')
        #print('****************************')
        
        #print('RIGHT/target SIDE:')
        check_index_access(sm_edge, 1)
        sm_target = get_value(sm_edge[1], sm)
        
        #TODO: to be replaced by respective similarity function
        gm_targets = get_gm_targets(gm, aimed_indices_source)
        similarity_scores = compute_similarity(sm_target, gm_targets, weights)
        aimed_indices_target = get_aimed_indices(similarity_scores, threshold)
        #print('#############################################')
        #print(f'AIMED_INDICES_target is {aimed_indices_target}')
        #print('#############################################')
        #find true positives
        for i_right in aimed_indices_target:
            check_index_access(aimed_indices_source, i_right)
            check_index_access(gm.edges, aimed_indices_source[i_right])
            gm_edge = gm.edges[aimed_indices_source[i_right]]
            #set true positives for sm and gm
            
            #the edge of the sm/gm has no match yet (if it already has one, skip) AND the types of the matches must be equivalent (e.g. excl.gateway and parallelgateway are not the same! this is the case for 1_2.mmd Index 6 of SM with BERT similarity)
            if all(sm_edge != pair[0] for pair in opt_eq_map) and all(gm_edge != pair[1] for pair in opt_eq_map) and types_equivalent(sm_edge, gm_edge):
                opt_eq_map.append((sm_edge, gm_edge))
                #print(f'MARKED INDEX {i} of SM as TRUE POSITIVE!!!!')
                #print(f'CORRESPONDING INDEX {aimed_indices_source[i_right]} OF GM TRUE POSITIVE!!!!!')
            #print('****************************')       
        #print(f'INDEX: {i} ENDING')
        
    #print('Final SM TUPLE:')
    #print(sm.edges)
    
    #print('Final GM TUPLE:')
    #print(gm.edges)
    return opt_eq_map


        
    